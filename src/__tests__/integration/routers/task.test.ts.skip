import { describe, it, expect, beforeEach, vi } from 'vitest';
import { createTestCaller } from '@/__tests__/utils/trpc-test-utils';

// Mock fetch for Google Calendar API calls
global.fetch = vi.fn();

describe('Task Router Integration Tests', () => {
  let mockDb: any;
  let caller: Awaited<ReturnType<typeof createTestCaller>>;
  let userId: string;
  let goalId: string;
  const mockUser = {
    id: 'user-123',
    email: 'test@example.com',
  };

  beforeEach(async () => {
    vi.clearAllMocks();
    
    // Create mock database chain
    const mockSelect = vi.fn().mockReturnThis();
    const mockInsert = vi.fn().mockReturnThis();
    const mockUpdate = vi.fn().mockReturnThis();
    const mockDelete = vi.fn().mockReturnThis();
    const mockEq = vi.fn().mockReturnThis();
    const mockOrder = vi.fn().mockReturnThis();
    const mockSingle = vi.fn();
    const mockMaybeSingle = vi.fn();
    const mockGte = vi.fn().mockReturnThis();
    const mockLte = vi.fn().mockReturnThis();
    const mockOverlaps = vi.fn().mockReturnThis();

    mockDb = {
      from: vi.fn(() => ({
        select: mockSelect,
        insert: mockInsert,
        update: mockUpdate,
        delete: mockDelete,
        eq: mockEq,
        gte: mockGte,
        lte: mockLte,
        overlaps: mockOverlaps,
        order: mockOrder,
        single: mockSingle,
        maybeSingle: mockMaybeSingle,
      })),
    };

    userId = mockUser.id;
    
    // Create test caller with mock context
    caller = await createTestCaller({
      user: mockUser as any,
      db: mockDb,
    });

    // Mock goal creation for tests that need it
    goalId = 'goal-123';
  });

  describe('Task CRUD Operations', () => {
    describe('create', () => {
      it('should create a task with minimal data', async () => {
        const mockTask = {
          id: 'task-123',
          user_id: userId,
          title: 'Simple Task',
          description: null,
          due_date: null,
          status: 'pending',
          completion_proof: null,
          tags: null,
          google_calendar_event_id: null,
          is_synced_with_calendar: false,
          parent_task_id: null,
          goal_id: null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        };

        mockDb.from().insert().select().maybeSingle.mockResolvedValue({
          data: mockTask,
          error: null,
        });

        const task = await caller.task.create({
          title: 'Simple Task',
        });

        expect(task).toBeDefined();
        expect(task.title).toBe('Simple Task');
        expect(task.status).toBe('pending');
        expect(task.isSyncedWithCalendar).toBe(false);
        expect(task.userId).toBe(userId);
      });

      it('should create a task with full data', async () => {
        const dueDate = new Date('2024-12-31T10:00:00Z');
        
        const task = await caller.task.create({
          title: 'Complete Task',
          description: 'Detailed description',
          dueDate,
          goalId,
          tags: ['work', 'urgent'],
          recurrenceRule: 'FREQ=DAILY;INTERVAL=1',
          syncWithCalendar: false,
        });

        expect(task.title).toBe('Complete Task');
        expect(task.description).toBe('Detailed description');
        expect(task.dueDate).toEqual(dueDate);
        expect(task.goalId).toBe(goalId);
        expect(task.tags).toEqual(['work', 'urgent']);
        expect(task.recurrenceRule).toBe('FREQ=DAILY;INTERVAL=1');
      });

      it('should create task and sync with Google Calendar when enabled', async () => {
        // Mock Google Calendar API response
        (global.fetch as any).mockResolvedValueOnce({
          ok: true,
          json: async () => ({ id: 'calendar-event-123' }),
        });

        const task = await caller.task.create({
          title: 'Calendar Task',
          syncWithCalendar: true,
        });

        expect(task.isSyncedWithCalendar).toBe(true);
        expect(task.googleCalendarEventId).toBe('calendar-event-123');
      });

      it('should create task without calendar sync when no integration exists', async () => {
        const task = await caller.task.create({
          title: 'Task without Calendar',
          syncWithCalendar: true,
        });

        // Should still create task even if calendar integration is not available
        expect(task).toBeDefined();
        expect(task.isSyncedWithCalendar).toBe(false);
      });
    });

    describe('getAll', () => {
      beforeEach(async () => {
        // Create test tasks
        await caller.task.create({
          title: 'Task 1',
          dueDate: new Date('2024-12-01'),
          status: 'pending',
        });
        await caller.task.create({
          title: 'Task 2',
          dueDate: new Date('2024-12-02'),
          tags: ['work'],
        });
        await caller.task.create({
          title: 'Task 3',
          goalId,
          status: 'completed',
        });
      });

      it('should get all tasks for user', async () => {
        const tasks = await caller.task.getAll();

        expect(tasks).toHaveLength(3);
        expect(tasks.map(t => t.title)).toContain('Task 1');
        expect(tasks.map(t => t.title)).toContain('Task 2');
        expect(tasks.map(t => t.title)).toContain('Task 3');
      });

      it('should filter tasks by status', async () => {
        const pendingTasks = await caller.task.getAll({ status: 'pending' });
        const completedTasks = await caller.task.getAll({ status: 'completed' });

        expect(pendingTasks).toHaveLength(2);
        expect(completedTasks).toHaveLength(1);
        expect(completedTasks[0].title).toBe('Task 3');
      });

      it('should filter tasks by goal', async () => {
        const goalTasks = await caller.task.getAll({ goalId });

        expect(goalTasks).toHaveLength(1);
        expect(goalTasks[0].title).toBe('Task 3');
      });

      it('should filter tasks by tags', async () => {
        const workTasks = await caller.task.getAll({ tags: ['work'] });

        expect(workTasks).toHaveLength(1);
        expect(workTasks[0].title).toBe('Task 2');
      });

      it('should filter tasks by date range', async () => {
        const tasksInDecember = await caller.task.getAll({
          startDate: new Date('2024-12-01'),
          endDate: new Date('2024-12-31'),
        });

        expect(tasksInDecember).toHaveLength(2);
      });
    });

    describe('getById', () => {
      it('should get task by ID', async () => {
        const created = await caller.task.create({
          title: 'Test Task',
          description: 'Test description',
        });

        const task = await caller.task.getById({ id: created.id });

        expect(task).toBeDefined();
        expect(task?.title).toBe('Test Task');
        expect(task?.description).toBe('Test description');
      });

      it('should return null for non-existent task', async () => {
        const task = await caller.task.getById({ id: 'non-existent-id' });

        expect(task).toBeNull();
      });
    });

    describe('update', () => {
      it('should update task title and description', async () => {
        const created = await caller.task.create({
          title: 'Original Title',
          description: 'Original description',
        });

        const updated = await caller.task.update({
          id: created.id,
          title: 'Updated Title',
          description: 'Updated description',
        });

        expect(updated.title).toBe('Updated Title');
        expect(updated.description).toBe('Updated description');
      });

      it('should update task due date', async () => {
        const created = await caller.task.create({
          title: 'Task with date',
          dueDate: new Date('2024-12-01'),
        });

        const newDate = new Date('2024-12-15');
        const updated = await caller.task.update({
          id: created.id,
          dueDate: newDate,
        });

        expect(updated.dueDate).toEqual(newDate);
      });

      it('should update task tags', async () => {
        const created = await caller.task.create({
          title: 'Task with tags',
          tags: ['old-tag'],
        });

        const updated = await caller.task.update({
          id: created.id,
          tags: ['new-tag', 'another-tag'],
        });

        expect(updated.tags).toEqual(['new-tag', 'another-tag']);
      });

      it('should link task to a goal', async () => {
        const created = await caller.task.create({
          title: 'Unlinked task',
        });

        const updated = await caller.task.update({
          id: created.id,
          goalId,
        });

        expect(updated.goalId).toBe(goalId);
      });
    });

    describe('delete', () => {
      it('should delete a task', async () => {
        const created = await caller.task.create({
          title: 'Task to delete',
        });

        const result = await caller.task.delete({ id: created.id });

        expect(result.success).toBe(true);
        expect(result.id).toBe(created.id);

        // Verify task is deleted
        const task = await caller.task.getById({ id: created.id });
        expect(task).toBeNull();
      });

      it('should throw error when deleting non-existent task', async () => {
        await expect(
          caller.task.delete({ id: 'non-existent-id' })
        ).rejects.toThrow();
      });
    });
  });

  describe('Task Status Management', () => {
    describe('complete', () => {
      it('should mark task as completed without proof', async () => {
        const created = await caller.task.create({
          title: 'Task to complete',
        });

        const completed = await caller.task.complete({
          id: created.id,
        });

        expect(completed.status).toBe('completed');
        expect(completed.completionProof).toBeNull();
      });

      it('should mark task as completed with proof', async () => {
        const created = await caller.task.create({
          title: 'Task to complete',
        });

        const completed = await caller.task.complete({
          id: created.id,
          proof: 'Completed successfully with evidence',
        });

        expect(completed.status).toBe('completed');
        expect(completed.completionProof).toBe('Completed successfully with evidence');
      });
    });

    describe('skip', () => {
      it('should mark task as skipped', async () => {
        const created = await caller.task.create({
          title: 'Task to skip',
        });

        const skipped = await caller.task.skip({
          id: created.id,
        });

        expect(skipped.status).toBe('skipped');
      });
    });

    describe('reschedule', () => {
      it('should reschedule task to new date', async () => {
        const created = await caller.task.create({
          title: 'Task to reschedule',
          dueDate: new Date('2024-12-01'),
        });

        const newDate = new Date('2024-12-15');
        const rescheduled = await caller.task.reschedule({
          id: created.id,
          newDueDate: newDate,
        });

        expect(rescheduled.dueDate).toEqual(newDate);
        expect(rescheduled.status).toBe('pending'); // Should reset status
      });

      it('should reset skipped task to pending when rescheduled', async () => {
        const created = await caller.task.create({
          title: 'Skipped task',
        });

        await caller.task.skip({ id: created.id });

        const newDate = new Date('2024-12-20');
        const rescheduled = await caller.task.reschedule({
          id: created.id,
          newDueDate: newDate,
        });

        expect(rescheduled.status).toBe('pending');
        expect(rescheduled.dueDate).toEqual(newDate);
      });
    });
  });

  describe('Google Calendar Sync', () => {
    describe('syncFromCalendar', () => {
      it('should sync events from Google Calendar', async () => {
        // Mock Google Calendar API responses
        (global.fetch as any)
          .mockResolvedValueOnce({
            ok: true,
            json: async () => ({
              items: [
                {
                  id: 'event-1',
                  summary: 'Calendar Event 1',
                  description: 'Event description',
                  start: { dateTime: '2024-12-01T10:00:00Z' },
                  end: { dateTime: '2024-12-01T11:00:00Z' },
                  status: 'confirmed',
                },
                {
                  id: 'event-2',
                  summary: 'Calendar Event 2',
                  start: { date: '2024-12-02' },
                  end: { date: '2024-12-02' },
                  status: 'confirmed',
                },
              ],
            }),
          });

        const result = await caller.task.syncFromCalendar();

        expect(result.success).toBe(true);
        expect(result.created).toBe(2);
        expect(result.total).toBe(2);

        // Verify tasks were created
        const tasks = await caller.task.getAll();
        expect(tasks.some(t => t.title === 'Calendar Event 1')).toBe(true);
        expect(tasks.some(t => t.title === 'Calendar Event 2')).toBe(true);
      });

      it('should update existing tasks from calendar', async () => {
        // Create a task first
        const created = await caller.task.create({
          title: 'Old Title',
          syncWithCalendar: false,
        });

        // Manually set google_calendar_event_id to simulate synced task
        // (In real scenario, this would be set when creating with calendar)
        
        // Mock calendar sync with updated event
        (global.fetch as any).mockResolvedValueOnce({
          ok: true,
          json: async () => ({
            items: [
              {
                id: 'event-123',
                summary: 'Updated Title',
                description: 'Updated description',
                start: { dateTime: '2024-12-01T10:00:00Z' },
                end: { dateTime: '2024-12-01T11:00:00Z' },
                status: 'confirmed',
              },
            ],
          }),
        });

        const result = await caller.task.syncFromCalendar();

        expect(result.success).toBe(true);
        // Should create new task since existing task has no calendar event ID
        expect(result.created).toBeGreaterThan(0);
      });

      it('should handle cancelled calendar events', async () => {
        // Mock cancelled event
        (global.fetch as any).mockResolvedValueOnce({
          ok: true,
          json: async () => ({
            items: [
              {
                id: 'cancelled-event',
                summary: 'Cancelled Event',
                start: { dateTime: '2024-12-01T10:00:00Z' },
                end: { dateTime: '2024-12-01T11:00:00Z' },
                status: 'cancelled',
              },
            ],
          }),
        });

        const result = await caller.task.syncFromCalendar();

        expect(result.success).toBe(true);
        // Cancelled events should not create tasks
        expect(result.created).toBe(0);
      });
    });
  });

  describe('Recurrence Rules', () => {
    it('should create task with daily recurrence', async () => {
      const task = await caller.task.create({
        title: 'Daily Task',
        recurrenceRule: 'FREQ=DAILY;INTERVAL=1',
      });

      expect(task.recurrenceRule).toBeDefined();
      expect(task.recurrenceRule).toBe('FREQ=DAILY;INTERVAL=1');
    });

    it('should create task with weekly recurrence', async () => {
      const task = await caller.task.create({
        title: 'Weekly Task',
        recurrenceRule: 'FREQ=WEEKLY;BYDAY=MO,WE,FR',
      });

      expect(task.recurrenceRule).toBe('FREQ=WEEKLY;BYDAY=MO,WE,FR');
    });

    it('should create task with custom RRULE', async () => {
      const task = await caller.task.create({
        title: 'Custom Recurrence Task',
        recurrenceRule: 'FREQ=WEEKLY;BYDAY=MO,WE,FR;UNTIL=20241231',
      });

      expect(task.recurrenceRule).toBe('FREQ=WEEKLY;BYDAY=MO,WE,FR;UNTIL=20241231');
    });
  });
});

